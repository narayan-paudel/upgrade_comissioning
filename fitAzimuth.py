#!/usr/bin/python
#
# fitAzimuth.py
#
# Created by Chris Wendt
#####  temporary issues bypassed:
#####     (1) amplitudes seem too large by a factor two, so divide that out
#####     (2) data files lack the "number of waveforms averaged" column
#
# usage: fitAzimuth.py geometry.txt fadcData.txt atwdData.txt
#
# geometry.txt tells where the strings are
#   (see below for the format and how you can generate it from the DB)
# fadcData.txt and atwdData give time and amplitude information describing
#   the average waveform seen at each receiver illuminated from some LED
#   (see below for detailed format)

import sys
import csv
import math
import heapq
from operator import itemgetter
from collections import defaultdict

# Parse command line
if len(sys.argv)!=4:
    print "Usage: ",sys.argv[0]," geometry.txt fadcData.txt atwdData.txt"
    sys.exit(1)
geometryFileName=sys.argv[1]
fadcDataFileName=sys.argv[2]
atwdDataFileName=sys.argv[3]

# average waveform quality cuts
minNAvg=100                # minimum number of hits contributing to average waveform
minPeak=.1                   # minimum peak value (mV)

# azimuthal orientation for each flasher, as determined from all receivers
#   keys should be [flasherString, flasherDepth]
#   value is list of orientations from all receivers that had successful fits
resultsDict=defaultdict(list)

# Read in the tab-delimited text file containing the string x,y positions
#   columns are expected to be:
#     string number
#     x (m)
#     y (m)
#   This file can be generated by the following command:
#        mysql -u www -h dbs2.icecube.wisc.edu < get_string_xy > geometry.txt
#        (then edit the resulting geometry.txt and remove the header line)
#   where the file "get_string_xy" contains the following mysql query:
#        use I3OmDb;
#        select StringId,X,Y from (select * from GeometryOm where TubeId=55 order by CaId desc) a group by StringId;
#
xGeometry={}
yGeometry={}
geoFile=open(geometryFileName,'r')
geoReader=csv.reader(geoFile,delimiter='\t',quoting=csv.QUOTE_NONNUMERIC)
for row in geoReader:
    string,x,y=row
    xGeometry[string]=x
    yGeometry[string]=y
geoFile.close()

# Read in the space-delimited text file summarizing the fadc waveform results
#   columns are expected to be separated by single spaces and contain the following:
#     peak of average atwd waveform (mV) ******** temporary fix: assumed too large by factor two
#     leading edge time of average waveform at 50% of peak value (nsec)
#     flasher string
#     flasher depth (1-60)
#     receiver string
#     receiver depth (1-60)
#     led mask (0-4095, but expect only 64, 128, 256, 512, 1024 or 2048)
fadcFile=open(fadcDataFileName,'r')
fadcReader=csv.reader(fadcFile,delimiter=' ',quoting=csv.QUOTE_NONNUMERIC)
fadcDict=defaultdict(list)
led_from_mask={1:1, 2:2, 4:3, 8:4, 16:5, 32:6, 64:7, 128:8, 256:9, 512:10, 1024:11, 2048:12}
for row in fadcReader:
    peakfadc=float(row[0])
    ### temporary fix for amplitudes
    peakfadc=peakfadc/2.
    t50fadc=float(row[1])
    flasherString=int(row[2])
    flasherDepth=int(row[3])
    receiverString=int(row[4])
    receiverDepth=int(row[5])
    mask=int(row[6])
    nAvg=int(row[7])
    junk1=float(row[8])
    junk2=float(row[9])
    junk3=float(row[10])
    junk4=float(row[11])
    junk5=float(row[12])
    junk6=float(row[13])
    junk7=float(row[14])
    junk8=float(row[15])
    junk9=float(row[16])
    led=led_from_mask[mask]
    if receiverString==flasherString: continue
    #### temporarily disabled cut on number of waveforms used
    if nAvg<minNAvg: continue
    fadcDict[receiverString,receiverDepth,flasherString,flasherDepth].append([led,nAvg,peakfadc,t50fadc])
fadcFile.close()

# Read in the space-delimited text file summarizing the atwd waveform results
#   columns are expected to be separated by single spaces and contain the following:
#     peak of average atwd waveform (mV) ******** temporary fix: assumed too large by factor two
#     leading edge time of average waveform at 50% of peak value (nsec)
#     flasher string
#     flasher depth (1-60)
#     receiver string
#     receiver depth (1-60)
#     led mask (0-4095, but expect only 64, 128, 256, 512, 1024 or 2048)
atwdFile=open(atwdDataFileName,'r')
atwdReader=csv.reader(atwdFile,delimiter=' ',quoting=csv.QUOTE_NONNUMERIC)
atwdDict=defaultdict(list)
led_from_mask={1:1, 2:2, 4:3, 8:4, 16:5, 32:6, 64:7, 128:8, 256:9, 512:10, 1024:11, 2048:12}
for row in atwdReader:
    peakatwd=float(row[0])
    ### temporary fix for amplitudes
    peakatwd=peakatwd/2.
    t50atwd=float(row[1])
    flasherString=int(row[2])
    flasherDepth=int(row[3])
    receiverString=int(row[4])
    receiverDepth=int(row[5])
    mask=int(row[6])
    nAvg=int(row[7])
    junk1=float(row[8])
    junk2=float(row[9])
    junk3=float(row[10])
    junk4=float(row[11])
    junk5=float(row[12])
    junk6=float(row[13])
    junk7=float(row[14])
    junk8=float(row[15])
    junk9=float(row[16])
    led=led_from_mask[mask]
    if receiverString==flasherString: continue
    #### temporarily disabled cut on number of waveforms used
    if nAvg<minNAvg: continue
    atwdDict[receiverString,receiverDepth,flasherString,flasherDepth].append([led,nAvg,peakatwd,t50atwd])
atwdFile.close()

# For every flasher/receiver pair, analyze results for each LED choice to find what LED
#   position corresponds to the direction vector from the flasher to the receiver,
#   and then use this to estimate the azimuthal orientation of the DOM's LED7
# normally we use fadc data, but if amplitudes go over 40mV then use atwd instead
for pair in atwdDict.keys():
    receiverString,receiverDepth,flasherString,flasherDepth=pair
    ampDict={}
    t50Dict={}
    # Check maximum amplitude, and substitute fadc data if under 40mV
    resultsByLED=atwdDict[pair]
    maxPeak=-999
    for resultSet in resultsByLED:
      led,nAvg,peak,t50=resultSet
      #led,peak,t50=resultSet
      if peak>maxPeak: maxPeak=peak
    if maxPeak<40: resultsByLED=fadcDict[pair]
    # Find what are the T50 values for each LED, and identify the earliest one
    earliestLED=0
    earliestT50=999999
    for resultSet in resultsByLED:
        led,nAvg,peak,t50=resultSet
        #led,peak,t50=resultSet
        if peak>minPeak:
            t50Dict[led]=t50
            t50Dict[led-6]=t50
            t50Dict[led+6]=t50
            if t50<earliestT50:
                earliestLED=led
                earliestT50=t50
                earliestPeak=peak
                earliestNAvg=nAvg
    # We use the set of three LEDs centered on the earliest, so check the
    #   surrounding ones are available
    if not t50Dict.has_key(earliestLED): continue
    if not t50Dict.has_key(earliestLED-1): continue
    if not t50Dict.has_key(earliestLED+1): continue
    #print pair
    #for resultSet in resultsByLED: print resultSet
    #print earliestLED,earliestT50,earliestPeak,earliestNAvg

    # Using the set of three LEDs centered on the earliest,
    #   fit quadratic to find LED position that would minimize T50
    #   (this is assumed to represent the LED position aligned with
    #   a vector from the flasher string to the receiver string)
    m0=0; m1=0; m2=0; m3=0; m4=0   # mk==sum of x**k
    u0=0; u1=0; u2=0               # uk==sum of y*x**k
    for led in range(earliestLED-1,earliestLED+2):
      x=led
      y=t50Dict[led]
      #print led,t50Dict[led]
      temp=1; m0+=temp; u0+=temp*y
      temp*=x; m1+=temp; u1+=temp*y
      temp*=x; m2+=temp; u2+=temp*y
      temp*=x; m3+=temp
      temp*=x; m4+=temp
    aNum=m2*m2*u0-m1*m3*u0-m1*m2*u1+m0*m3*u1+m1*m1*u2-m0*m2*u2
    bNum=-(m2*m3*u0-m1*m4*u0-m2*m2*u1+m0*m4*u1+m1*m2*u2-m0*m3*u2)
    if aNum==0: continue
    ledPositionMin=-bNum/2/aNum
    if ledPositionMin<7: ledPositionMin+=6
    if ledPositionMin>=13: ledPositionMin-=6
    #print ledPositionMin

    # compute azimuthal orientation of LED7 on flasher DOM and add to list of results for flasher
    #   N.B. LED numbers increase in clockwise direction, looking down on top of the DOM
    #   (use degrees for units)
    deltaPhi=60*(ledPositionMin-7)
    phiReceiver=math.atan2(yGeometry[receiverString]-yGeometry[flasherString],
                           xGeometry[receiverString]-xGeometry[flasherString])*180/math.pi
    phiLED7=(phiReceiver+deltaPhi)%360
    resultsDict[flasherString,flasherDepth].append([(receiverString,receiverDepth),earliestPeak,phiLED7])
# For each flasher DOM, look at the list of orientation estimates and determine a sort of average.
#   Method: add up gaussians centered at each estimate, normalized by earliestPeak for that estimate,
#           and see where is the highest point on this sum of gaussians
width=10  # width of gaussian
print "flasher string\tflasher depth\tbest phi_7 (deg)\tsigma of best 3(deg)\tbest peak(mV)"
for flasher in sorted(resultsDict.keys()):
    estimateList=resultsDict[flasher]
    flasherString,flasherDepth=flasher
    outFile=open("results-flasher-%02d-%02d.txt" % (flasherString,flasherDepth),"w")
    print >>outFile, "Receiver\tEarliest Peak (mV)\tphi(LED7), deg"
    for estimate in estimateList:
        receiver,earliestPeak,phiLED7=estimate
        print >>outFile,"%s\t%f\t%f" % (receiver,earliestPeak,phiLED7)
    outFile.close()
    bestAngle=-1
    bestHeight=-1
    bestEarliestPeak=-1
    for (receiver,earliestPeak,phiLED7) in estimateList:
        if earliestPeak>bestEarliestPeak: bestEarliestPeak=earliestPeak
    for angle in range(360):
        height=0
        for estimate in estimateList:
            receiver,earliestPeak,phiLED7=estimate
            delta=(angle-phiLED7)%360.
            if delta>180: delta-=360.
            height+=earliestPeak*math.exp(-.5*(delta/width)**2)
        if height>bestHeight:
            bestHeight=height
            bestAngle=angle
    # check the spread of results from the three receivers with the largest values of earliestPeak height
    bestEstimates=heapq.nlargest(3,estimateList,itemgetter(1))
    nBest=len(bestEstimates)
    if nBest>=2:
        sum=0.
        for (receiver,earliestPeak,phiLED7) in bestEstimates: 
            dphi=phiLED7-bestAngle
            if dphi>180: dphi-=360
            if dphi<-180: dphi+=360
            sum+=dphi
        avg=sum/nBest
        sumDev2=0.
        for (receiver,earliestPeak,phiLED7) in bestEstimates: 
            dphi=phiLED7-bestAngle
            if dphi>180: dphi-=360
            if dphi<-180: dphi+=360
            sumDev2+=(dphi-avg)**2
        sigma3=math.sqrt(sumDev2/(nBest-1.))
    else:
        sigma3=999.
    print "%d\t%d\t%f\t%f\t%f"%(flasherString,flasherDepth,bestAngle,sigma3,bestEarliestPeak)
